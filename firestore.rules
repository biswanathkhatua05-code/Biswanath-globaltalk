
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isUser(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function isCreator() {
      // Check if the user document exists and the isCreator field is true
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isCreator == true;
    }

    // USERS
    // Users can read any profile.
    // Users can only create or update their OWN profile document.
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create, update: if isUser(userId);
    }

    // GLOBAL MESSAGES
    // Anyone signed in can read.
    // Anyone signed in can write, but only as themselves.
    match /global_messages/{messageId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
    }

    // PRIVATE CHAT SESSIONS
    // Only participants can read/write messages. The session ID is a composite key "uid1_uid2"
    match /chat_sessions/{sessionId}/messages/{messageId} {
        function isPrivateChatParticipant() {
            return isSignedIn() && request.auth.uid in sessionId.split('_');
        }
        allow read, write: if isPrivateChatParticipant();
    }
    
    // RANDOM CHAT
    match /random_chat_sessions_pool/{sessionId} {
        allow list: if isSignedIn(); 
        allow create: if isSignedIn() && request.resource.data.userId1 == request.auth.uid;
        allow get: if isSignedIn() && (
            resource.data.userId1 == request.auth.uid || 
            (resource.data.userId2 != null && resource.data.userId2 == request.auth.uid)
        );
        allow update: if isSignedIn() && (
            (request.resource.data.userId2 == request.auth.uid && resource.data.userId2 == null) || 
            (resource.data.userId1 == request.auth.uid || (resource.data.userId2 != null && resource.data.userId2 == request.auth.uid))
        );
    }
    
    match /random_chat_sessions_pool/{sessionId}/messages/{messageId} {
        function isRandomChatParticipant() {
            let session = get(/databases/$(database)/documents/random_chat_sessions_pool/$(sessionId)).data;
            return isSignedIn() && (
                session.userId1 == request.auth.uid ||
                (session.userId2 != null && session.userId2 == request.auth.uid)
            );
        }
        allow read, write: if isRandomChatParticipant();
    }

    // VIDEOS PLATFORM
    match /videos/{videoId} {
      allow read: if isSignedIn();
      allow create: if isCreator();
      allow update: if isSignedIn() && resource.data.creatorId == request.auth.uid;
      
      match /likes/{userId} {
        allow read: if isSignedIn();
        allow create: if isUser(userId);
        allow delete: if isUser(userId);
      }
      
      match /comments/{commentId} {
        allow read: if isSignedIn();
        allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      }
    }
    
    // WEBRTC SIGNALING
    function isCallParticipant(callId) {
        // callId is expected to be 'uid1_uid2'
        return isSignedIn() && request.auth.uid in callId.split('_');
    }

    match /video_calls/{callId} {
        allow read, write, delete: if isCallParticipant(callId);
        match /offerCandidates/{candidateId} { allow read, create: if isCallParticipant(callId); }
        match /answerCandidates/{candidateId} { allow read, create: if isCallParticipant(callId); }
    }

    match /voice_calls/{callId} {
        allow read, write, delete: if isCallParticipant(callId);
        match /offerCandidates/{candidateId} { allow read, create: if isCallParticipant(callId); }
        match /answerCandidates/{candidateId} { allow read, create: if isCallParticipant(callId); }
    }
  }
}
