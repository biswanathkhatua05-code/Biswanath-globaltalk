rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
  
    // =================================
    // Helper Functions
    // =================================
    function isSignedIn() {
      return request.auth != null;
    }

    // Securely checks if a user is part of a random chat session.
    function isRandomChatParticipant(sessionId) {
      let docPath = /databases/$(database)/documents/random_chat_sessions_pool/$(sessionId);
      if (!exists(docPath)) {
        return false;
      }
      let sessionData = get(docPath).data;
      // Also check if userId2 is present, otherwise comparison is with null
      return request.auth.uid == sessionData.userId1 || (sessionData.keys().hasAny(['userId2']) && request.auth.uid == sessionData.userId2);
    }
    
    // Checks if a user is part of a private chat based on the ID format.
    function isPrivateChatParticipant(sessionId) {
        return request.auth.uid in sessionId.split('_');
    }

    // =================================
    // Collections
    // =================================

    // Global chat messages can be read by anyone, written by signed-in users.
    match /global_messages/{messageId} {
      allow read: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if false;
    }

    // Private chat sessions and their messages.
    match /chat_sessions/{sessionId}/{document=**} {
      allow read, write: if isSignedIn() && isPrivateChatParticipant(sessionId);
    }
    
    // Random chat session management.
    match /random_chat_sessions_pool/{sessionId} {
      // Allow signed-in users to query for waiting sessions.
      allow read: if isSignedIn();
      
      // Allow a user to create a new waiting session for themselves.
      allow create: if isSignedIn() 
                    && request.resource.data.userId1 == request.auth.uid
                    && request.resource.data.status == 'waiting';

      // Allow updates for joining or disconnecting.
      allow update: if isSignedIn() && (
        // Case 1: A second user joins a waiting session.
        (resource.data.status == 'waiting' 
          && request.resource.data.status == 'active' 
          && request.resource.data.userId2 == request.auth.uid
          && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'userId2', 'user2', 'updatedAt'])) 
        ||
        // Case 2: A participant disconnects from an active session.
        (resource.data.status == 'active' 
          && request.resource.data.status == 'disconnected' 
          && (request.auth.uid == resource.data.userId1 || request.auth.uid == resource.data.userId2)
          && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'disconnectedAt']))
      );
    }

    // Messages within a random chat session.
    match /random_chat_sessions_pool/{sessionId}/messages/{messageId} {
        allow read: if isSignedIn() && isRandomChatParticipant(sessionId);
        allow create: if isSignedIn() 
                      && isRandomChatParticipant(sessionId)
                      && request.resource.data.userId == request.auth.uid;
        allow update, delete: if false;
    }

    // WebRTC Signaling for video calls.
    // Kept simple to avoid introducing new issues. For production, this could be
    // tightened by checking if the user is a participant of the parent chat.
    match /video_calls/{callId}/{document=**} {
      allow read, write: if isSignedIn();
    }
  }
}
