
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions
    function isUserAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isUserAuthenticated() && request.auth.uid == userId;
    }

    // USERS collection rules
    // Users can read any profile, but only write to their own.
    // They cannot make themselves a creator; this must be done server-side/manually.
    match /users/{userId} {
      allow read;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId)
                    // Check that a user is not trying to make themselves a creator
                    && request.resource.data.isCreator == resource.data.isCreator;
    }

    // GLOBAL MESSAGES rules
    // Anyone can read, but only authenticated users can write.
    match /global_messages/{messageId} {
      allow read;
      allow create: if isUserAuthenticated() && request.resource.data.userId == request.auth.uid;
      // No updates or deletes allowed for global messages to keep the history.
      allow update, delete: if false;
    }

    // CHAT SESSIONS (Private Chats) rules
    // Only participants of the chat can read or write messages.
    function isPrivateChatParticipant(chatId) {
      let participants = split(chatId, '_');
      return request.auth.uid in participants;
    }
    
    match /chat_sessions/{chatId} {
      allow get: if isPrivateChatParticipant(chatId);
      
      match /messages/{messageId} {
        allow read, write: if isPrivateChatParticipant(chatId);
      }
    }

    // RANDOM CHAT SESSIONS POOL rules
    function isRandomChatParticipant(sessionId) {
      let session = get(/databases/$(database)/documents/random_chat_sessions_pool/$(sessionId)).data;
      // Check if the user is either userId1 or userId2 in the session document.
      return request.auth.uid == session.userId1 || request.auth.uid == session.userId2;
    }

    match /random_chat_sessions_pool/{sessionId} {
      // Allow read/write on the session doc itself if the user is a participant.
      allow read, write: if isUserAuthenticated() && (
                            // Allow creating a new session
                            request.resource.data.userId1 == request.auth.uid ||
                            // Allow joining an existing session
                            isRandomChatParticipant(sessionId)
                          );

      match /messages/{messageId} {
        // Allow read/write messages only if the user is a confirmed participant of the session.
        allow read, write: if isUserAuthenticated() && isRandomChatParticipant(sessionId);
      }
    }
    
    // VIDEO and VOICE CALL signaling rules
    function isCallParticipant(callId) {
       // Call ID for private/random is the chat ID/session ID
       // Check if it's a private chat
       let isPrivate = exists(/databases/$(database)/documents/chat_sessions/$(callId));
       // Check if it's a random chat
       let isRandom = exists(/databases/$(database)/documents/random_chat_sessions_pool/$(callId));

       if (isPrivate) {
         return isPrivateChatParticipant(callId);
       }
       if (isRandom) {
         return isRandomChatParticipant(callId);
       }
       return false;
    }

    match /video_calls/{callId} {
      allow read, write, delete: if isUserAuthenticated() && isCallParticipant(callId);
      match /offerCandidates/{candidateId} {
        allow read, write, delete: if isUserAuthenticated() && isCallParticipant(callId);
      }
      match /answerCandidates/{candidateId} {
        allow read, write, delete: if isUserAuthenticated() && isCallParticipant(callId);
      }
    }
    
    match /voice_calls/{callId} {
      allow read, write, delete: if isUserAuthenticated() && isCallParticipant(callId);
      match /offerCandidates/{candidateId} {
        allow read, write, delete: if isUserAuthenticated() && isCallParticipant(callId);
      }
      match /answerCandidates/{candidateId} {
        allow read, write, delete: if isUserAuthenticated() && isCallParticipant(callId);
      }
    }

    // VIDEO PLATFORM rules
    // Videos can be read by anyone, but only created/updated/deleted by their creator.
    match /videos/{videoId} {
      allow read;
      allow create: if isUserAuthenticated()
                     // User must be a creator
                     && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isCreator == true
                     // Creator ID in the video must match the authenticated user
                     && request.resource.data.creatorId == request.auth.uid;
      allow update, delete: if isUserAuthenticated() && resource.data.creatorId == request.auth.uid;

      // Comments can be read by anyone.
      // Logged-in users can add comments.
      // Users can only edit/delete their own comments.
      match /comments/{commentId} {
        allow read;
        allow create: if isUserAuthenticated()
                       && request.resource.data.authorId == request.auth.uid;
        allow update, delete: if isUserAuthenticated() && resource.data.authorId == request.auth.uid;
      }
      
      // Likes: a user can only like/unlike a video once.
      // The document id is the user's UID.
      match /likes/{userId} {
        allow read;
        allow create, delete: if isOwner(userId);
      }
    }
  }
}
