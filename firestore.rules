rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
  
    // =================================
    // Users Collection
    // =================================
    // Rules for the 'users' collection where user profiles are stored.
    match /users/{userId} {
      // Any authenticated user can create their own user profile document.
      allow create: if request.auth != null && request.auth.uid == userId;
      
      // Any authenticated user can read any user's profile.
      // This is needed to see other users' names and avatars.
      allow get: if request.auth != null;
      
      // A user can only update their own profile.
      allow update: if request.auth != null && request.auth.uid == userId;
      
      // Users cannot delete their profiles.
      allow delete: if false;
    }
    
    // =================================
    // Videos Collection
    // =================================
    // Rules for the 'videos' collection and their subcollections.
    match /videos/{videoId} {
      // Any authenticated user can view video documents.
      allow get: if request.auth != null;
      
      // Only users marked as 'isCreator' can create, update, or delete videos.
      allow write: if request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isCreator == true;
      
      // Rules for the 'comments' subcollection within a video.
      match /comments/{commentId} {
        // Any authenticated user can read comments.
      	allow list, get: if request.auth != null;
        // An authenticated user can create a comment, but can only update/delete their own.
        allow create: if request.auth != null;
        allow update, delete: if request.auth != null && request.resource.data.authorId == request.auth.uid;
      }
      
      // Rules for the 'likes' subcollection within a video.
      match /likes/{userId} {
      	// An authenticated user can read likes.
        allow get: if request.auth != null;
        // A user can only create a like document with their own userId.
        // They cannot update it (to prevent unliking/re-liking spam) and cannot delete it.
        allow create: if request.auth != null && request.auth.uid == userId;
        allow update, delete: if false;
      }
    }

    // =================================
    // Global Chat
    // =================================
    // Rules for the public global chat room.
    match /global_messages/{messageId} {
      // Any authenticated user can read and write to the global chat.
      allow read, write: if request.auth != null;
    }

    // =================================
    // Private Chat
    // =================================
    // Rules for one-on-one private chat sessions.
    match /chat_sessions/{chatId} {
      // Allow read/write access only if the logged-in user is one of the participants.
      // The chatId must be a combination of the two user UIDs, sorted alphabetically.
      allow read, write: if request.auth != null && request.auth.uid in resource.data.participants
                          && chatId.split('_')[0] < chatId.split('_')[1] // Ensure consistent ID format
                          && (request.auth.uid == chatId.split('_')[0] || request.auth.uid == chatId.split('_')[1]);
                          
      // Messages subcollection within a private chat
      match /messages/{messageId} {
         // Allow read/write only if the user is a participant of the parent chat session.
      	 allow read, write: if request.auth != null && request.auth.uid in get(/databases/$(database)/documents/chat_sessions/$(chatId)).data.participants;
      }
    }
    
    // =================================
    // Random Chat Pool
    // =================================
    // Rules for the pool where users wait for a random partner.
    match /random_chat_sessions_pool/{sessionId} {
      // Any authenticated user can read the list of waiting sessions.
      allow list, get: if request.auth != null;
      
      // A user can create a new session if they are userId1.
      // A user can join (update) a session if it's waiting and they are not userId1.
      allow create: if request.auth != null && request.resource.data.userId1 == request.auth.uid;
      allow update: if request.auth != null; // Allow updates for status changes (active, disconnected)
      
      // Messages subcollection within a random chat
      match /messages/{messageId} {
         // Allow read/write only if the user is one of the two participants in the random chat.
         allow read, write: if request.auth != null && 
                             (request.auth.uid == get(/databases/$(database)/documents/random_chat_sessions_pool/$(sessionId)).data.userId1 ||
                              request.auth.uid == get(/databases/$(database)/documents/random_chat_sessions_pool/$(sessionId)).data.userId2);
      }
    }

    // =================================
    // Call Signaling (WebRTC)
    // =================================
    // These rules are intentionally open for authenticated users to allow 
    // the exchange of WebRTC signaling messages (offers, answers, candidates).
    // The actual call data is peer-to-peer and does not go through Firestore.
    match /video_calls/{callId} {
    	allow read, write, delete: if request.auth != null;
      match /offerCandidates/{candidateId} {
      	allow read, write, delete: if request.auth != null;
      }
      match /answerCandidates/{candidateId} {
      	allow read, write, delete: if request.auth != null;
      }
    }
    
    match /voice_calls/{callId} {
    	allow read, write, delete: if request.auth != null;
      match /offerCandidates/{candidateId} {
      	allow read, write, delete: if request.ah != null;
      }
      match /answerCandidates/{candidateId} {
      	allow read, write, delete: if request.auth != null;
      }
    }
  }
}
